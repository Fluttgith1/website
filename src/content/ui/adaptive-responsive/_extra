
When creating a layout that automatically adapts
to the size and shape of the user's device,
there are several things you might keep in mind.
This page covers how to take an app built for a
phone and make it beautiful on a wide range of devices.

### Screen-based breakpoints

The simplest form of procedural layouts uses
screen-based breakpoints. There are no
hard and fast rules for the sizes to use
here, but these are general values:

<?code-excerpt "lib/global/device_size.dart (form-factor)"?>
```dart
class FormFactor {
  static double desktop = 900;
  static double tablet = 600;
  static double handset = 300;
}
```

Screen-based breakpoints are best used for making
top-level decisions in your app. Changing things like
visual density, paddings, or font-sizes are best when
defined on a global basis.

You can also use screen-based breakpoints to reflow your
top-level widget trees. For example, you could switch
from a vertical to a horizontal layout when
the user isn't on a handset (mobile device):

Learn more in the following 5-minute video:

<iframe width="560" height="315" src="{{site.yt.embed}}/HD5gYnspYzk?si=KvEOAYbOn7lAfKmP" title="Learn the difference between adaptive and responsive apps" {{site.yt-set}}></iframe>
[Adaptive vs responsive][]

[Adaptive vs responsive]: {{site.youtube-site}}/watch?v=HD5gYnspYzk

---

## Creating an adaptive Flutter app

You might also check out the following episodes
of The Boring Show:

<iframe style="max-width: 100%" width="560" height="315" src="{{site.yt.embed}}/n6Awpg1MO6M" title="Learn about adaptative layouts on the Boring Show" {{site.yt-set}}></iframe>
[Adaptive layouts][]

<iframe style="max-width: 100%" width="560" height="315" src="{{site.yt.embed}}/eikOZzfc0l4" title="Continue to learn about adaptative layouts on the Boring Show" {{site.yt-set}}></iframe>
[Adaptive layouts, part 2][]

For a great example of an adaptive app,
check out Flutter Folio, a scrapbooking app created
in collaboration with gskinner and the Flutter team:

<iframe style="max-width: 100%" width="560" height="315" src="{{site.yt.embed}}/yytBENOnF0w" title="Watch a demonstration of the Flutter Folio app" {{site.yt-set}}></iframe>

[Adaptive layouts]: {{site.yt.watch}}?v=n6Awpg1MO6M&t=694s
[Adaptive layouts, part 2]: {{site.yt.watch}}?v=eikOZzfc0l4&t=11s

### Other resources

You can learn more about creating platform-adaptive apps
in the following resources:

* [Platform-specific behaviors and adaptations][],
  a page on this site.
* [Designing truly adaptive user interfaces][],
  presented at the Flutter Vikings 2020 conference
  by Alo√Øs Deniel,

[Designing truly adaptive user interfaces]: https://www.aloisdeniel.com/blog/designing-truly-adaptative-user-interfaces
[Platform-specific behaviors and adaptations]: /platform-integration/platform-adaptations

### Contextual layout

If you need more than density changes and can't find a
widget that does what you need, you can take a more
procedural approach to adjust parameters, calculate sizes,
swap widgets, or completely restructure your UI to suit
a particular form factor.

#### Use LayoutBuilder for extra flexibility

Even though checking total screen size is great for
full-screen pages or making global layout decisions,
it's often not ideal for nested subviews.
Often, subviews have their own internal breakpoints
and care only about the space that they have available to render.

The simplest way to handle this in Flutter is using the
[`LayoutBuilder`][] class. `LayoutBuilder` allows a
widget to respond to incoming local size constraints,
which can make the widget more versatile than if it
depended on a global value.

The previous example could be rewritten using `LayoutBuilder`:

<?code-excerpt "lib/widgets/extra_widget_excerpts.dart (layout-builder)"?>
```dart
Widget foo = LayoutBuilder(builder: (context, constraints) {
  bool useVerticalLayout = constraints.maxWidth < 400;
  return Flex(
    direction: useVerticalLayout ? Axis.vertical : Axis.horizontal,
    children: const [
      Text('Hello'),
      Text('World'),
    ],
  );
});
```

This widget can now be composed within a side panel,
dialog, or even a full-screen view,
and adapt its layout to whatever space is provided.

#### Device segmentation

There are times when you want to make layout decisions
based on the actual platform you're running on,
regardless of size. For example, when building a
custom title bar, you might need to check the operating
system type and tweak the layout of your title bar,
so it doesn't get covered by the native window buttons.

To determine which combination of platforms you're on,
you can use the [`Platform`][] API along with the `kIsWeb` value:

<?code-excerpt "lib/global/device_type.dart (platforms)"?>
```dart
bool get isMobileDevice => !kIsWeb && (Platform.isIOS || Platform.isAndroid);
bool get isDesktopDevice =>
    !kIsWeb && (Platform.isMacOS || Platform.isWindows || Platform.isLinux);
bool get isMobileDeviceOrWeb => kIsWeb || isMobileDevice;
bool get isDesktopDeviceOrWeb => kIsWeb || isDesktopDevice;
```

The `Platform` API can't be accessed from web builds without
throwing an exception, because the `dart.io` package isn't
supported on the web target. As a result, the above code checks
for web first, and because of short-circuiting,
Dart never calls `Platform` on web targets.

Use `Platform`/`kIsWeb` when the logic absolutely <i>must</i>
run for a given platform. For example,
talking to a plugin that only works on iOS,
or displaying a widget that only conforms to
Play Store policy and not the App Store's.

[`Platform`]: {{site.api}}/flutter/package-platform_platform/Platform-class.html

### Single source of truth for styling

You'll probably find it easier to maintain your views
if you create a single source of truth for styling values
like padding, spacing, corner shape, font sizes, and so on.
This can be done easily with some helper classes:

<?code-excerpt "lib/global/device_type.dart (styling)"?>
```dart
class Insets {
  static const double xsmall = 3;
  static const double small = 4;
  static const double medium = 5;
  static const double large = 10;
  static const double extraLarge = 20;
  // etc
}

class Fonts {
  static const String raleway = 'Raleway';
  // etc
}

class TextStyles {
  static const TextStyle raleway = TextStyle(
    fontFamily: Fonts.raleway,
  );
  static TextStyle buttonText1 =
      const TextStyle(fontWeight: FontWeight.bold, fontSize: 14);
  static TextStyle buttonText2 =
      const TextStyle(fontWeight: FontWeight.normal, fontSize: 11);
  static TextStyle h1 =
      const TextStyle(fontWeight: FontWeight.bold, fontSize: 22);
  static TextStyle h2 =
      const TextStyle(fontWeight: FontWeight.bold, fontSize: 16);
  static TextStyle body1 = raleway.copyWith(color: const Color(0xFF42A5F5));
  // etc
}
```

These constants can then be used in place of hard-coded numeric values:

<?code-excerpt "lib/global/device_type.dart (use-constants)"?>
```dart
return Padding(
  padding: const EdgeInsets.all(Insets.small),
  child: Text('Hello!', style: TextStyles.body1),
);
```

Use `Theme.of(context).platform` for theming and
design choices, like what kind of switches to show
and general Cupertino/Material adaptions.

With all views referencing the same shared-design system rules,
they tend to look better and more consistent.
Making a change or adjusting a value for a specific platform
can be done in a single place, instead of using an error-prone
search and replace. Using shared rules has the added benefit
of helping enforce consistency on the design side.

Some common design system categories that can be represented
this way are:

* Animation timings
* Sizes and breakpoints
* Insets and paddings
* Corner radius
* Shadows
* Strokes
* Font families, sizes, and styles

Like most rules, there are exceptions:
one-off values that are used nowhere else in the app.
There is little point in cluttering up the styling rules
with these values, but it's worth considering if they
should be derived from an existing value (for example,
`padding + 1.0`). You should also watch for reuse or duplication
of the same semantic values. Those values should likely be
added to the global styling ruleset.

### Use desktop build targets for rapid testing

One of the most effective ways to test adaptive
interfaces is to take advantage of the desktop build targets.

When running on a desktop, you can easily resize the window
while the app is running to preview various screen sizes.
This, combined with hot reload, can greatly accelerate the
development of a responsive UI.

![Adaptive scaffold 2](/assets/images/docs/ui/adaptive-responsive/adaptive_scaffold2.gif){:width="100%"}

### Support multi-window mode

Use the `MediaQuery.sizeOf` and `LayoutBuilder` classes,
which reflect the app area and available widget area, respectively.

Use the [`Display`][] class, which
supports Android's [window size classes][],
to determine the full screen size an app can use,
and to distinguish a small device from
a large, multi-screen device.

:::secondary Warning
This class should _only_ be used
when you need to know the physical display
capabilities. In most situations, use `MediaQuery`.
:::

The `Display` class allows you to retrieve
various properties of a display,
such as physical size, pixel ratio,
and refresh rate.
The [`FlutterView.display`][] getter returns
a `Display` object.<br><br>

For an example that uses this method,
check out the [`setPreferredOrientations`][] API.

[`FlutterView.display`]: {{site.api}}/flutter/dart-ui/FlutterView/display.html
[`MediaQuery`]: {{site.api}}/flutter/widgets/MediaQuery-class.html
[`setPreferredOrientations`]: {{site.api}}/flutter/services/SystemChrome/setPreferredOrientations.html
[window size classes]: {{site.android-dev}}/guide/topics/large-screens/support-different-screen-sizes#window_size_classes

### Other resources

For more information, here are a few resources,
including contributions from the Flutter community:

* [Developing for Multiple Screen Sizes and Orientations in
  Flutter][] by Deven Joshi
* [Build Responsive UIs in Flutter][] by Raouf Rahiche
* [Making Cross-platform Flutter Landing Page Responsive][]
  by Priyanka Tyagi
* [How to make flutter app responsive according to different screen
  size?][], a question on StackOverflow

[`BoxConstraints`]: {{site.api}}/flutter/rendering/BoxConstraints-class.html
[Build Responsive UIs in Flutter]: {{site.medium}}/flutter-community/build-responsive-uis-in-flutter-fd450bd59158
[`builder`]: {{site.api}}/flutter/widgets/LayoutBuilder/builder.html
[Developing for Multiple Screen Sizes and Orientations in Flutter]: {{site.medium}}/flutter-community/developing-for-multiple-screen-sizes-and-orientations-in-flutter-fragments-in-flutter-a4c51b849434

[How to make flutter app responsive according to different screen size?]: {{site.so}}/questions/49704497/how-to-make-flutter-app-responsive-according-to-different-screen-size
[`LayoutBuilder`]: {{site.api}}/flutter/widgets/LayoutBuilder-class.html
[Making Cross-platform Flutter Landing Page Responsive]: {{site.medium}}/flutter-community/making-cross-platform-flutter-landing-page-responsive-7fffe0655970
